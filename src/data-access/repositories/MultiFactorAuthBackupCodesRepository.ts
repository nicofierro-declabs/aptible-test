import { Service } from "typedi";
import Objection from "objection";
import speakeasy from "speakeasy";
import { MultiFactorAuthBackupCodesModel } from "../models/multi_factor_auth_backup_codes.model";
import { BaseRepository } from "./BaseRepository";

@Service()
export class MultiFactorAuthBackupCodesRepository extends BaseRepository<MultiFactorAuthBackupCodesModel> {

  /**
   * 
   * @param userId 
   * @param authToken 
   * @param index 
   * @param trx 
   * @returns Objection.Expression<string>
   * Returns the string of a db insert of a single backup code.
   */
  private registerMfaBackupCode = (
    userId: number,
    authToken: string,
    index: number,
    trx: Objection.Transaction
  ): Objection.Expression<string> => {
    const token = speakeasy.totp({
      secret: authToken,
      encoding: "base32",
      time: new Date().getTime() - (index + 1) * 60 * 60 * 1000,
    });
    const backupCode = { portalUserId: userId, token };
    return MultiFactorAuthBackupCodesModel.query(trx).insert(
      backupCode as MultiFactorAuthBackupCodesModel
    );
  };

  /**
   * 
   * @param userId 
   * @param secret 
   * @param trx 
   * Creates an array of strings to store all db inserts commands generated by "registerMfaBackupCode" method.
   * Is a total of 6 backup codes
   * After the generation process finishes. A Promise.all is used to improve performance.
   */
  async createBackupCodes(
    userId: number,
    secret: string,
    trx: Objection.Transaction
  ): Promise<any> {
    const queries = [];
    for (let i = 0; i < 6; i++) {
      queries.push(this.registerMfaBackupCode(userId, secret, i, trx));
    }
    await Promise.all(queries);
  }

  /**
   * 
   * @param userId 
   * @returns backup codes db query result.
   */
  async getUserBackupCodes(userId: number) {
    const codes = await this.find([
      {
        column: "portalUserId",
        operator: "=",
        value: `${userId}`,
      },
    ]);
    return codes;
  }

  /**
   * 
   * @param userId 
   * @param trx 
   * Fetches the backup codes of a given user, then deletes all of them.
   * Uses a Promise.all to improve performance.
   */
  private async deleteBackupCodes(userId: number, trx?: Objection.Transaction): Promise<void> {
    const oldCodes = await this.getUserBackupCodes(userId);
    if(oldCodes) {
      const queries: any[] = [];
      oldCodes.forEach(async code => {
        queries.push(this.delete(code.id!, trx));
      });
      await Promise.all(queries);
    };
  };

  /**
   * 
   * @param userId 
   * @param secret 
   * Deletes all backup codes of a given user, then created a new batch.
   */
  async generateNewBackupCodes(userId: number, secret: string): Promise<any> {
    const trx = await MultiFactorAuthBackupCodesModel.startTransaction();
    try {
      await this.deleteBackupCodes(userId, trx);
      await this.createBackupCodes(userId, secret, trx);
      trx.commit();
    } catch (error) {
      trx.rollback();
      throw new Error(error);
    }
  }

}
